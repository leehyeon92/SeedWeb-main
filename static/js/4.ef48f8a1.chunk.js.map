{"version":3,"sources":["../../../node_modules/@ethersproject/logger/lib.esm/index.js","../../../node_modules/@ethersproject/logger/lib.esm/_version.js","../../../node_modules/@ethersproject/properties/lib.esm/_version.js","../../../node_modules/@ethersproject/properties/lib.esm/index.js","../../../src/api/alchemy-provider.ts","../../../src/internal/websocket-backfiller.ts","../../../src/internal/internal-types.ts","../../../src/api/alchemy-websocket-provider.ts","../../src/index.ts","../node_modules/websocket/lib/browser.js","../node_modules/es5-ext/global.js","../node_modules/websocket/lib/version.js","../../src.ts/browser-ws.ts","../../src.ts/websocket-provider.ts"],"names":["_permanentCensorErrors","_censorErrors","LogLevels","debug","info","warning","error","off","_logLevel","_globalLogger","LogLevel","ErrorCode","_normalizeError","missing","forEach","form","normalize","Error","push","length","join","String","fromCharCode","message","_checkNormalize","HEX","Logger","version","Object","defineProperty","this","enumerable","value","writable","logLevel","args","level","toLowerCase","throwArgumentError","console","log","apply","_log","levels","DEBUG","INFO","WARNING","code","params","makeError","errors","UNKNOWN_ERROR","messageDetails","keys","key","Uint8Array","hex","i","JSON","stringify","toString","reason","url","NUMERIC_FAULT","fault","CALL_EXCEPTION","INSUFFICIENT_FUNDS","MISSING_NEW","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","TRANSACTION_REPLACED","UNPREDICTABLE_GAS_LIMIT","name","throwError","INVALID_ARGUMENT","argument","condition","UNSUPPORTED_OPERATION","operation","count","expectedCount","MISSING_ARGUMENT","UNEXPECTED_ARGUMENT","target","kind","censorship","permanent","globalLogger","warn","logger","defineReadOnly","object","opaque","bigint","boolean","number","string","_isFrozen","undefined","Array","isArray","isFrozen","_deepCopy","freeze","map","item","deepCopy","result","AlchemyProvider","config","apiKey","getApiKey","alchemyNetwork","getAlchemyNetwork","network","connection","getAlchemyConnectionInfo","throttleLimit","maxRetries","ethersNetwork","detectNetwork","method","_send","methodName","request","id","_nextId","jsonrpc","emit","action","provider","cache","indexOf","_cache","headers","getResult","then","response","setTimeout","getNetworkFromEthers","values","includes","type","allowGzip","payload","data","WebsocketBackfiller","isCancelled","previousHeads","fromBlockNumber","throwIfCancelled","getBlockNumber","toBlockNumber","getHeadEventsInRange","Math","max","maxBackfillBlocks","lastSeenBlockNumber","minBlockNumber","getReorgHeads","reorgHeads","intermediateHeads","filter","previousLogs","getLogsInRange","blockNumber","getCommonAncestor","commonAncestor","removedLogs","removed","fromBlockInclusive","Number","NEGATIVE_INFINITY","addedLogs","logIndex","newMax","send","blockNumberHex","toBlockExclusive","batchParts","sendBatch","batchedBlockHeads","blockHeads","reduce","acc","batch","concat","toNewHeadsEvent","oldEvent","getBlockByNumber","blockHead","hash","reverse","oldLog","blockHash","rangeFilter","fromBlock","toBlock","head","totalDifficulty","transactions","uncles","dedupeNewHeads","events","dedupe","event","dedupeLogs","items","getKey","keysSeen","Set","has","add","CANCELLED","ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE","ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD","EthersEvent","comps","tag","split","deserializeAddressField","listener","once","_lastBlockNumber","_inflight","address","topics","topic","deserializeTopics","addresses","AlchemyWebSocketProvider","wsConstructor","protocol","ws","process","versions","node","w3cwebsocket","WebSocket","virtualSubscriptionsById","Map","virtualIdsByPhysicalId","handleMessage","parse","isResponse","isSubscriptionEvent","physicalId","subscription","virtualId","get","newHeadsSubscription","newHeadsMessage","isBackfilling","backfillBuffer","pastEvents","addToPastEventsBuffer","getNewHeadsBlockNumber","addToNewHeadsEventsBuffer","emitAndRememberEvent","rememberEvent","logsSubscription","logsMessage","getLogsBlockNumber","addToLogsEventsBuffer","clear","cancelled","cancel","makeCancelToken","cancelBackfill","resubscribeAndBackfill","startHeartbeat","heartbeatIntervalId","clearInterval","backfiller","addSocketListeners","eventName","_addEventListener","isAlchemyEvent","_off","_removeAllListeners","_listenerCount","_listeners","verifyAlchemyEventName","getAlchemyEventTag","_events","_startEvent","customStartEvent","param","processFunc","subIdPromise","_subIds","startingBlockNumber","Promise","all","subId","resolvedParams","set","sentEvents","_subs","stopped","eventTag","_stopEvent","parts","nextId","sendBatchConcurrently","errorResponse","find","r","sort","r1","r2","removeSocketListeners","stopHeartbeatAndBackfill","e","listenerCount","_websocket","addEventListener","handleReopen","removeEventListener","withBackoffRetries","withTimeout","getNewHeadsBackfill","backfillEvents","emitNewHeadsEvent","getLogsBackfill","emitLogsEvent","emitGenericEvent","emitProcessFn","emitFunction","setInterval","reconnect","req","fromAddress","toAddress","hashesOnly","_subscribe","_getFilter","from","toNumber","_emitted","block","formatter","filterLog","removeAllListeners","found","f","retryCount","shouldRetry","nextWaitTime","delay","min","ms","resolve","promise","race","_","reject","currentBlockNumber","firstGoodIndex","findIndex","splice","field","serializeAddressField","protocolsOrOptions","options","onclose","onerror","onmessage","onopen","ondown","onreopen","CONNECTING","SturdyWebSocket","OPEN","CLOSING","CLOSED","hasBeenOpened","isClosed","messageBuffer","nextRetryTime","reconnectCount","lastKnownExtensions","lastKnownProtocol","listeners","protocols","applyDefaultOptions","openNewWebSocket","binaryTypeInternal","binaryType","sum","bufferedAmount","hasUnknownAmount","byteLength","ArrayBuffer","Blob","size","getDataByteLength","debugLog","extensions","close","disposeSocket","shutdown","readyState","handleClose","dispatchEvent","dispatchEventOfType","l","connectTimeout","handleError","handleOpen","connectTimeoutId","clearConnectTimeout","allClearResetTime","allClearTimeoutId","clearAllClearTimeout","openTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","noop","clearTimeout","slice","callListener","defaultPrevented","call","handleEvent","s","DEFAULT_OPTIONS","POSITIVE_INFINITY","_globalThis","globalThis","require","window","NativeWebSocket","MozWebSocket","websocket_version","W3CWebSocket","uri","prop","module","exports","naiveFallback","self","prototype","configurable","__global__"],"mappings":"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","file":"static/js/4.ef48f8a1.chunk.js","sourcesContent":["\"use strict\";\nlet _permanentCensorErrors = false;\nlet _censorErrors = false;\nconst LogLevels = { debug: 1, \"default\": 2, info: 2, warning: 3, error: 4, off: 5 };\nlet _logLevel = LogLevels[\"default\"];\nimport { version } from \"./_version\";\nlet _globalLogger = null;\nfunction _checkNormalize() {\n    try {\n        const missing = [];\n        // Make sure all forms of normalization are supported\n        [\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach((form) => {\n            try {\n                if (\"test\".normalize(form) !== \"test\") {\n                    throw new Error(\"bad normalize\");\n                }\n                ;\n            }\n            catch (error) {\n                missing.push(form);\n            }\n        });\n        if (missing.length) {\n            throw new Error(\"missing \" + missing.join(\", \"));\n        }\n        if (String.fromCharCode(0xe9).normalize(\"NFD\") !== String.fromCharCode(0x65, 0x0301)) {\n            throw new Error(\"broken implementation\");\n        }\n    }\n    catch (error) {\n        return error.message;\n    }\n    return null;\n}\nconst _normalizeError = _checkNormalize();\nexport var LogLevel;\n(function (LogLevel) {\n    LogLevel[\"DEBUG\"] = \"DEBUG\";\n    LogLevel[\"INFO\"] = \"INFO\";\n    LogLevel[\"WARNING\"] = \"WARNING\";\n    LogLevel[\"ERROR\"] = \"ERROR\";\n    LogLevel[\"OFF\"] = \"OFF\";\n})(LogLevel || (LogLevel = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n    ///////////////////\n    // Generic Errors\n    // Unknown Error\n    ErrorCode[\"UNKNOWN_ERROR\"] = \"UNKNOWN_ERROR\";\n    // Not Implemented\n    ErrorCode[\"NOT_IMPLEMENTED\"] = \"NOT_IMPLEMENTED\";\n    // Unsupported Operation\n    //   - operation\n    ErrorCode[\"UNSUPPORTED_OPERATION\"] = \"UNSUPPORTED_OPERATION\";\n    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n    //   - event (\"noNetwork\" is not re-thrown in provider.ready; otherwise thrown)\n    ErrorCode[\"NETWORK_ERROR\"] = \"NETWORK_ERROR\";\n    // Some sort of bad response from the server\n    ErrorCode[\"SERVER_ERROR\"] = \"SERVER_ERROR\";\n    // Timeout\n    ErrorCode[\"TIMEOUT\"] = \"TIMEOUT\";\n    ///////////////////\n    // Operational  Errors\n    // Buffer Overrun\n    ErrorCode[\"BUFFER_OVERRUN\"] = \"BUFFER_OVERRUN\";\n    // Numeric Fault\n    //   - operation: the operation being executed\n    //   - fault: the reason this faulted\n    ErrorCode[\"NUMERIC_FAULT\"] = \"NUMERIC_FAULT\";\n    ///////////////////\n    // Argument Errors\n    // Missing new operator to an object\n    //  - name: The name of the class\n    ErrorCode[\"MISSING_NEW\"] = \"MISSING_NEW\";\n    // Invalid argument (e.g. value is incompatible with type) to a function:\n    //   - argument: The argument name that was invalid\n    //   - value: The value of the argument\n    ErrorCode[\"INVALID_ARGUMENT\"] = \"INVALID_ARGUMENT\";\n    // Missing argument to a function:\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"MISSING_ARGUMENT\"] = \"MISSING_ARGUMENT\";\n    // Too many arguments\n    //   - count: The number of arguments received\n    //   - expectedCount: The number of arguments expected\n    ErrorCode[\"UNEXPECTED_ARGUMENT\"] = \"UNEXPECTED_ARGUMENT\";\n    ///////////////////\n    // Blockchain Errors\n    // Call exception\n    //  - transaction: the transaction\n    //  - address?: the contract address\n    //  - args?: The arguments passed into the function\n    //  - method?: The Solidity method signature\n    //  - errorSignature?: The EIP848 error signature\n    //  - errorArgs?: The EIP848 error parameters\n    //  - reason: The reason (only for EIP848 \"Error(string)\")\n    ErrorCode[\"CALL_EXCEPTION\"] = \"CALL_EXCEPTION\";\n    // Insufficient funds (< value + gasLimit * gasPrice)\n    //   - transaction: the transaction attempted\n    ErrorCode[\"INSUFFICIENT_FUNDS\"] = \"INSUFFICIENT_FUNDS\";\n    // Nonce has already been used\n    //   - transaction: the transaction attempted\n    ErrorCode[\"NONCE_EXPIRED\"] = \"NONCE_EXPIRED\";\n    // The replacement fee for the transaction is too low\n    //   - transaction: the transaction attempted\n    ErrorCode[\"REPLACEMENT_UNDERPRICED\"] = \"REPLACEMENT_UNDERPRICED\";\n    // The gas limit could not be estimated\n    //   - transaction: the transaction passed to estimateGas\n    ErrorCode[\"UNPREDICTABLE_GAS_LIMIT\"] = \"UNPREDICTABLE_GAS_LIMIT\";\n    // The transaction was replaced by one with a higher gas price\n    //   - reason: \"cancelled\", \"replaced\" or \"repriced\"\n    //   - cancelled: true if reason == \"cancelled\" or reason == \"replaced\")\n    //   - hash: original transaction hash\n    //   - replacement: the full TransactionsResponse for the replacement\n    //   - receipt: the receipt of the replacement\n    ErrorCode[\"TRANSACTION_REPLACED\"] = \"TRANSACTION_REPLACED\";\n    ///////////////////\n    // Interaction Errors\n    // The user rejected the action, such as signing a message or sending\n    // a transaction\n    ErrorCode[\"ACTION_REJECTED\"] = \"ACTION_REJECTED\";\n})(ErrorCode || (ErrorCode = {}));\n;\nconst HEX = \"0123456789abcdef\";\nexport class Logger {\n    constructor(version) {\n        Object.defineProperty(this, \"version\", {\n            enumerable: true,\n            value: version,\n            writable: false\n        });\n    }\n    _log(logLevel, args) {\n        const level = logLevel.toLowerCase();\n        if (LogLevels[level] == null) {\n            this.throwArgumentError(\"invalid log level name\", \"logLevel\", logLevel);\n        }\n        if (_logLevel > LogLevels[level]) {\n            return;\n        }\n        console.log.apply(console, args);\n    }\n    debug(...args) {\n        this._log(Logger.levels.DEBUG, args);\n    }\n    info(...args) {\n        this._log(Logger.levels.INFO, args);\n    }\n    warn(...args) {\n        this._log(Logger.levels.WARNING, args);\n    }\n    makeError(message, code, params) {\n        // Errors are being censored\n        if (_censorErrors) {\n            return this.makeError(\"censored error\", code, {});\n        }\n        if (!code) {\n            code = Logger.errors.UNKNOWN_ERROR;\n        }\n        if (!params) {\n            params = {};\n        }\n        const messageDetails = [];\n        Object.keys(params).forEach((key) => {\n            const value = params[key];\n            try {\n                if (value instanceof Uint8Array) {\n                    let hex = \"\";\n                    for (let i = 0; i < value.length; i++) {\n                        hex += HEX[value[i] >> 4];\n                        hex += HEX[value[i] & 0x0f];\n                    }\n                    messageDetails.push(key + \"=Uint8Array(0x\" + hex + \")\");\n                }\n                else {\n                    messageDetails.push(key + \"=\" + JSON.stringify(value));\n                }\n            }\n            catch (error) {\n                messageDetails.push(key + \"=\" + JSON.stringify(params[key].toString()));\n            }\n        });\n        messageDetails.push(`code=${code}`);\n        messageDetails.push(`version=${this.version}`);\n        const reason = message;\n        let url = \"\";\n        switch (code) {\n            case ErrorCode.NUMERIC_FAULT: {\n                url = \"NUMERIC_FAULT\";\n                const fault = message;\n                switch (fault) {\n                    case \"overflow\":\n                    case \"underflow\":\n                    case \"division-by-zero\":\n                        url += \"-\" + fault;\n                        break;\n                    case \"negative-power\":\n                    case \"negative-width\":\n                        url += \"-unsupported\";\n                        break;\n                    case \"unbound-bitwise-result\":\n                        url += \"-unbound-result\";\n                        break;\n                }\n                break;\n            }\n            case ErrorCode.CALL_EXCEPTION:\n            case ErrorCode.INSUFFICIENT_FUNDS:\n            case ErrorCode.MISSING_NEW:\n            case ErrorCode.NONCE_EXPIRED:\n            case ErrorCode.REPLACEMENT_UNDERPRICED:\n            case ErrorCode.TRANSACTION_REPLACED:\n            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:\n                url = code;\n                break;\n        }\n        if (url) {\n            message += \" [ See: https:/\\/links.ethers.org/v5-errors-\" + url + \" ]\";\n        }\n        if (messageDetails.length) {\n            message += \" (\" + messageDetails.join(\", \") + \")\";\n        }\n        // @TODO: Any??\n        const error = new Error(message);\n        error.reason = reason;\n        error.code = code;\n        Object.keys(params).forEach(function (key) {\n            error[key] = params[key];\n        });\n        return error;\n    }\n    throwError(message, code, params) {\n        throw this.makeError(message, code, params);\n    }\n    throwArgumentError(message, name, value) {\n        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n            argument: name,\n            value: value\n        });\n    }\n    assert(condition, message, code, params) {\n        if (!!condition) {\n            return;\n        }\n        this.throwError(message, code, params);\n    }\n    assertArgument(condition, message, name, value) {\n        if (!!condition) {\n            return;\n        }\n        this.throwArgumentError(message, name, value);\n    }\n    checkNormalize(message) {\n        if (message == null) {\n            message = \"platform missing String.prototype.normalize\";\n        }\n        if (_normalizeError) {\n            this.throwError(\"platform missing String.prototype.normalize\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"String.prototype.normalize\", form: _normalizeError\n            });\n        }\n    }\n    checkSafeUint53(value, message) {\n        if (typeof (value) !== \"number\") {\n            return;\n        }\n        if (message == null) {\n            message = \"value not safe\";\n        }\n        if (value < 0 || value >= 0x1fffffffffffff) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"out-of-safe-range\",\n                value: value\n            });\n        }\n        if (value % 1) {\n            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n                operation: \"checkSafeInteger\",\n                fault: \"non-integer\",\n                value: value\n            });\n        }\n    }\n    checkArgumentCount(count, expectedCount, message) {\n        if (message) {\n            message = \": \" + message;\n        }\n        else {\n            message = \"\";\n        }\n        if (count < expectedCount) {\n            this.throwError(\"missing argument\" + message, Logger.errors.MISSING_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n        if (count > expectedCount) {\n            this.throwError(\"too many arguments\" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n                count: count,\n                expectedCount: expectedCount\n            });\n        }\n    }\n    checkNew(target, kind) {\n        if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    checkAbstract(target, kind) {\n        if (target === kind) {\n            this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(kind.name) + \" directly; use a sub-class\", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: \"new\" });\n        }\n        else if (target === Object || target == null) {\n            this.throwError(\"missing new\", Logger.errors.MISSING_NEW, { name: kind.name });\n        }\n    }\n    static globalLogger() {\n        if (!_globalLogger) {\n            _globalLogger = new Logger(version);\n        }\n        return _globalLogger;\n    }\n    static setCensorship(censorship, permanent) {\n        if (!censorship && permanent) {\n            this.globalLogger().throwError(\"cannot permanently disable censorship\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        if (_permanentCensorErrors) {\n            if (!censorship) {\n                return;\n            }\n            this.globalLogger().throwError(\"error censorship permanent\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"setCensorship\"\n            });\n        }\n        _censorErrors = !!censorship;\n        _permanentCensorErrors = !!permanent;\n    }\n    static setLogLevel(logLevel) {\n        const level = LogLevels[logLevel.toLowerCase()];\n        if (level == null) {\n            Logger.globalLogger().warn(\"invalid log level - \" + logLevel);\n            return;\n        }\n        _logLevel = level;\n    }\n    static from(version) {\n        return new Logger(version);\n    }\n}\nLogger.errors = ErrorCode;\nLogger.levels = LogLevel;\n//# sourceMappingURL=index.js.map","export const version = \"logger/5.7.0\";\n//# sourceMappingURL=_version.js.map","export const version = \"properties/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function defineReadOnly(object, name, value) {\n    Object.defineProperty(object, name, {\n        enumerable: true,\n        value: value,\n        writable: false,\n    });\n}\n// Crawl up the constructor chain to find a static method\nexport function getStatic(ctor, key) {\n    for (let i = 0; i < 32; i++) {\n        if (ctor[key]) {\n            return ctor[key];\n        }\n        if (!ctor.prototype || typeof (ctor.prototype) !== \"object\") {\n            break;\n        }\n        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n    }\n    return null;\n}\nexport function resolveProperties(object) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const promises = Object.keys(object).map((key) => {\n            const value = object[key];\n            return Promise.resolve(value).then((v) => ({ key: key, value: v }));\n        });\n        const results = yield Promise.all(promises);\n        return results.reduce((accum, result) => {\n            accum[(result.key)] = result.value;\n            return accum;\n        }, {});\n    });\n}\nexport function checkProperties(object, properties) {\n    if (!object || typeof (object) !== \"object\") {\n        logger.throwArgumentError(\"invalid object\", \"object\", object);\n    }\n    Object.keys(object).forEach((key) => {\n        if (!properties[key]) {\n            logger.throwArgumentError(\"invalid object key - \" + key, \"transaction:\" + key, object);\n        }\n    });\n}\nexport function shallowCopy(object) {\n    const result = {};\n    for (const key in object) {\n        result[key] = object[key];\n    }\n    return result;\n}\nconst opaque = { bigint: true, boolean: true, \"function\": true, number: true, string: true };\nfunction _isFrozen(object) {\n    // Opaque objects are not mutable, so safe to copy by assignment\n    if (object === undefined || object === null || opaque[typeof (object)]) {\n        return true;\n    }\n    if (Array.isArray(object) || typeof (object) === \"object\") {\n        if (!Object.isFrozen(object)) {\n            return false;\n        }\n        const keys = Object.keys(object);\n        for (let i = 0; i < keys.length; i++) {\n            let value = null;\n            try {\n                value = object[keys[i]];\n            }\n            catch (error) {\n                // If accessing a value triggers an error, it is a getter\n                // designed to do so (e.g. Result) and is therefore \"frozen\"\n                continue;\n            }\n            if (!_isFrozen(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\n// Returns a new copy of object, such that no properties may be replaced.\n// New properties may be added only to objects.\nfunction _deepCopy(object) {\n    if (_isFrozen(object)) {\n        return object;\n    }\n    // Arrays are mutable, so we need to create a copy\n    if (Array.isArray(object)) {\n        return Object.freeze(object.map((item) => deepCopy(item)));\n    }\n    if (typeof (object) === \"object\") {\n        const result = {};\n        for (const key in object) {\n            const value = object[key];\n            if (value === undefined) {\n                continue;\n            }\n            defineReadOnly(result, key, deepCopy(value));\n        }\n        return result;\n    }\n    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, \"object\", object);\n}\nexport function deepCopy(object) {\n    return _deepCopy(object);\n}\nexport class Description {\n    constructor(info) {\n        for (const key in info) {\n            this[key] = deepCopy(info[key]);\n        }\n    }\n}\n//# sourceMappingURL=index.js.map","import {\n  JsonRpcProvider,\n  CommunityResourcable\n} from '@ethersproject/providers';\nimport {\n  Network as NetworkFromEthers,\n  Networkish,\n  getNetwork as getNetworkFromEthers\n} from '@ethersproject/networks';\nimport { ConnectionInfo, fetchJson } from '@ethersproject/web';\nimport { deepCopy } from '@ethersproject/properties';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  DEFAULT_NETWORK,\n  EthersNetwork,\n  getAlchemyHttpUrl,\n  getAlchemyWsUrl\n} from '../util/const';\nimport { Network } from '../types/types';\nimport { logWarn } from '../util/logger';\nimport { VERSION } from '../version';\nimport { IS_BROWSER } from '../util/util';\nimport { AlchemyConfig } from './alchemy-config';\n\n/**\n * SDK's custom implementation of ethers.js's 'AlchemyProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getProvider()}.\n *\n * @public\n */\nexport class AlchemyProvider\n  extends JsonRpcProvider\n  implements CommunityResourcable\n{\n  readonly apiKey: string;\n  readonly maxRetries: number;\n\n  /** @internal */\n  constructor(config: AlchemyConfig) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'http'\n    );\n\n    // If a hardcoded url was specified in the config, use that instead of the\n    // provided apiKey or network.\n    if (config.url !== undefined) {\n      connection.url = config.url;\n    }\n\n    connection.throttleLimit = config.maxRetries;\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(connection, ethersNetwork);\n\n    this.apiKey = config.apiKey;\n    this.maxRetries = config.maxRetries;\n  }\n\n  /**\n   * Overrides the `UrlJsonRpcProvider.getApiKey` method as implemented by\n   * ethers.js. Returns the API key for an Alchemy provider.\n   *\n   * @internal\n   * @override\n   */\n  static getApiKey(apiKey: any): string {\n    if (apiKey == null) {\n      return DEFAULT_ALCHEMY_API_KEY;\n    }\n    if (apiKey && typeof apiKey !== 'string') {\n      throw new Error(\n        `Invalid apiKey '${apiKey}' provided. apiKey must be a string.`\n      );\n    }\n    return apiKey;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Converts the `Networkish` input to the network enum used by Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyNetwork(network?: Networkish): Network {\n    if (network === undefined) {\n      return DEFAULT_NETWORK;\n    }\n\n    if (typeof network === 'number') {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be a string.`\n      );\n    }\n\n    // Guaranteed that `typeof network === 'string`.\n    const isValidNetwork = Object.values(Network).includes(network as Network);\n    if (!isValidNetwork) {\n      throw new Error(\n        `Invalid network '${network}' provided. Network must be one of: ` +\n          `${Object.values(Network).join(', ')}.`\n      );\n    }\n    return network as Network;\n  }\n\n  /**\n   * Returns a {@link ConnectionInfo} object compatible with ethers that contains\n   * the correct URLs for Alchemy.\n   *\n   * @internal\n   */\n  static getAlchemyConnectionInfo(\n    network: Network,\n    apiKey: string,\n    type: 'wss' | 'http'\n  ): ConnectionInfo {\n    const url =\n      type === 'http'\n        ? getAlchemyHttpUrl(network, apiKey)\n        : getAlchemyWsUrl(network, apiKey);\n    return {\n      headers: IS_BROWSER\n        ? {\n            'Alchemy-Ethers-Sdk-Version': VERSION\n          }\n        : {\n            'Alchemy-Ethers-Sdk-Version': VERSION,\n            'Accept-Encoding': 'gzip'\n          },\n      allowGzip: true,\n      url\n    };\n  }\n\n  /**\n   * Overrides the method in ethers.js's `StaticJsonRpcProvider` class. This\n   * method is called when calling methods on the parent class `BaseProvider`.\n   *\n   * @override\n   */\n  async detectNetwork(): Promise<NetworkFromEthers> {\n    let network = this.network;\n    if (network == null) {\n      network = await super.detectNetwork();\n\n      if (!network) {\n        throw new Error('No network detected');\n      }\n    }\n    return network;\n  }\n\n  _startPending(): void {\n    logWarn('WARNING: Alchemy Provider does not support pending filters');\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * Overrides the base {@link JsonRpcProvider.send} method to implement custom\n   * logic for sending requests to Alchemy.\n   *\n   * @param method The method name to use for the request.\n   * @param params The parameters to use for the request.\n   * @override\n   * @public\n   */\n  // TODO: Add headers for `perform()` override.\n  send(method: string, params: Array<any>): Promise<any> {\n    return this._send(method, params, 'send');\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `JsonRpcProvider.send()`.\n   *\n   * This method is copied over directly in order to implement custom headers\n   *\n   * @internal\n   */\n  _send(method: string, params: Array<any>, methodName: string): Promise<any> {\n    const request = {\n      method,\n      params,\n      id: this._nextId++,\n      jsonrpc: '2.0'\n    };\n\n    this.emit('debug', {\n      action: 'request',\n      request: deepCopy(request),\n      provider: this\n    });\n\n    // We can expand this in the future to any call, but for now these\n    // are the biggest wins and do not require any serializing parameters.\n    const cache = ['eth_chainId', 'eth_blockNumber'].indexOf(method) >= 0;\n    if (cache && this._cache[method]) {\n      return this._cache[method];\n    }\n\n    // START MODIFIED CODE\n    const connection = { ...this.connection };\n    connection.headers!['Alchemy-Ethers-Sdk-Method'] = methodName;\n    // END MODIFIED CODE\n\n    const result = fetchJson(\n      this.connection,\n      JSON.stringify(request),\n      getResult\n    ).then(\n      result => {\n        this.emit('debug', {\n          action: 'response',\n          request,\n          response: result,\n          provider: this\n        });\n\n        return result;\n      },\n      error => {\n        this.emit('debug', {\n          action: 'response',\n          error,\n          request,\n          provider: this\n        });\n\n        throw error;\n      }\n    );\n\n    // Cache the fetch, but clear it on the next event loop\n    if (cache) {\n      this._cache[method] = result;\n      setTimeout(() => {\n        // @ts-ignore - This is done by ethers.\n        this._cache[method] = null;\n      }, 0);\n    }\n\n    return result;\n  }\n}\n\n/**\n * DO NOT MODIFY.\n *\n * Original code copied over from ether.js's\n * `@ethersproject/web/src.ts/index.ts`. Used to support\n * {@link AlchemyProvider._send}, which is also copied over.\n */\nfunction getResult(payload: {\n  error?: { code?: number; data?: any; message?: string };\n  result?: any;\n}): any {\n  if (payload.error) {\n    const error: any = new Error(payload.error.message);\n    error.code = payload.error.code;\n    error.data = payload.error.data;\n    throw error;\n  }\n\n  return payload.result;\n}\n","import { fromHex, toHex } from '../api/util';\nimport { AlchemyWebSocketProvider } from '../api/alchemy-websocket-provider';\n\nexport interface BatchPart {\n  method: string;\n  params?: any;\n}\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/** The return type of eth_getBlocksByHash. */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\nexport interface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\ninterface CommonAncestor {\n  blockNumber: number;\n  logIndex: number;\n}\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\n/**\n * The WebsocketBackfiller fetches events that were sent since a provided block\n * number. This is used in the {@link AlchemyWebSocketProvider} to backfill\n * events that were transmitted while the websocket connection was down.\n *\n * The backfiller backfills two main eth_subscribe events: `logs` and `newHeads`.\n *\n * @internal\n */\nexport class WebsocketBackfiller {\n  // TODO: Use HTTP provider to do backfill.\n  private maxBackfillBlocks = MAX_BACKFILL_BLOCKS;\n  constructor(private readonly provider: AlchemyWebSocketProvider) {}\n\n  /**\n   * Runs backfill for `newHeads` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param previousHeads Previous head requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   * @returns A list of `newHeads` events that were sent since the last backfill.\n   */\n  async getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous heads to fetch, return new heads since\n    // `fromBlockNumber`, or up to maxBackfillBlocks from the current head.\n    if (previousHeads.length === 0) {\n      return this.getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted event is too far back in the past, there's no need\n    // to backfill for reorgs. Just fetch the last `maxBackfillBlocks` worth of\n    // new heads.\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber <= minBlockNumber) {\n      return this.getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n\n    // To capture all `newHeads` events, return all head events from the last\n    // seen block number to current + any of the previous heads that were re-orged.\n    const reorgHeads: NewHeadsEvent[] = await this.getReorgHeads(\n      isCancelled,\n      previousHeads\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await this.getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  /**\n   * Runs backfill for `logs` events.\n   *\n   * @param isCancelled Whether the backfill request is cancelled.\n   * @param filter The filter object that accompanies a logs subscription.\n   * @param previousLogs Previous log requests that were sent.\n   * @param fromBlockNumber The block number to start backfilling from.\n   */\n  async getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await this.getBlockNumber();\n    throwIfCancelled(isCancelled);\n\n    // If there are no previous logs to fetch, return new logs since\n    // `fromBlockNumber`, or up to `maxBackfillBlocks` from the current head.\n    if (previousLogs.length === 0) {\n      return this.getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - this.maxBackfillBlocks) + 1,\n        toBlockNumber + 1\n      );\n    }\n\n    // If the last emitted log is too far back in the past, there's no need\n    // to backfill for removed logs. Just fetch the last `maxBackfillBlocks`\n    // worth of logs.\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber\n    );\n    const minBlockNumber = toBlockNumber - this.maxBackfillBlocks + 1;\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return this.getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n\n    // Return all log events that have happened along with log events that have\n    // been removed due to a chain reorg.\n    const commonAncestor = await this.getCommonAncestor(\n      isCancelled,\n      previousLogs\n    );\n    throwIfCancelled(isCancelled);\n\n    // All previous logs with a block number greater than the common ancestor\n    // were part of a re-org, so mark them as such.\n    const removedLogs = previousLogs\n      .filter(log => fromHex(log.blockNumber) > commonAncestor.blockNumber)\n      .map(log => ({ ...log, removed: true }));\n\n    // If no common ancestor was found, start backfill from the oldest log's\n    // block number.\n    const fromBlockInclusive =\n      commonAncestor.blockNumber === Number.NEGATIVE_INFINITY\n        ? fromHex(previousLogs[0].blockNumber)\n        : commonAncestor.blockNumber;\n    let addedLogs = await this.getLogsInRange(\n      filter,\n      fromBlockInclusive,\n      toBlockNumber + 1\n    );\n\n    // De-dupe any logs that were already emitted.\n    addedLogs = addedLogs.filter(\n      log =>\n        log &&\n        (fromHex(log.blockNumber) > commonAncestor.blockNumber ||\n          fromHex(log.logIndex) > commonAncestor.logIndex)\n    );\n\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  /**\n   * Sets a new max backfill blocks. VISIBLE ONLY FOR TESTING.\n   *\n   * @internal\n   */\n  setMaxBackfillBlock(newMax: number): void {\n    this.maxBackfillBlocks = newMax;\n  }\n\n  /**\n   * Gets the current block number as a number.\n   *\n   * @private\n   */\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.provider.send('eth_blockNumber');\n    return fromHex(blockNumberHex);\n  }\n\n  /**\n   * Gets all `newHead` events in the provided range. Note that the returned\n   * heads do not include re-orged heads. Use {@link getReorgHeads} to find heads\n   * that were part of a re-org.\n   *\n   * @private\n   */\n  private async getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: 'eth_getBlockByNumber',\n        params: [toHex(i), false]\n      });\n    }\n\n    // TODO: just fire off each send() separately since we're no longer batching:\n    // TODO: handle errors\n    const batchedBlockHeads = await this.provider.sendBatch(batchParts);\n    const blockHeads = batchedBlockHeads.reduce(\n      (acc, batch) => acc.concat(batch),\n      []\n    );\n    return blockHeads.map(toNewHeadsEvent);\n  }\n\n  /**\n   * Returns all heads that were part of a reorg event.\n   *\n   * @private\n   */\n  private async getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[]\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await this.getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n\n      // If the hashes match, then current head in the iteration was not re-orged.\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  /**\n   * Simple wrapper around `eth_getBlockByNumber` that returns the complete\n   * block information for the provided block number.\n   *\n   * @private\n   */\n  private async getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return this.provider.send('eth_getBlockByNumber', [\n      toHex(blockNumber),\n      false\n    ]);\n  }\n\n  /**\n   * Given a list of previous log events, finds the common block number from the\n   * logs that matches the block head.\n   *\n   * This can be used to identify which logs are part of a re-org.\n   *\n   * Returns 1 less than the oldest log's block number if no common ancestor was found.\n   *\n   * @private\n   */\n  private async getCommonAncestor(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[]\n  ): Promise<CommonAncestor> {\n    // Iterate from the most recent head backwards in order to find the first\n    // block that was part of a re-org.\n    let blockHead = await this.getBlockByNumber(\n      fromHex(previousLogs[previousLogs.length - 1].blockNumber)\n    );\n    throwIfCancelled(isCancelled);\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const oldLog = previousLogs[i];\n\n      // Ensure that updated blocks are fetched every time the log's block number\n      // changes.\n      if (oldLog.blockNumber !== blockHead.number) {\n        blockHead = await this.getBlockByNumber(fromHex(oldLog.blockNumber));\n      }\n\n      // Since logs are ordered in ascending order, the first log that matches\n      // the hash should be the largest logIndex.\n      if (oldLog.blockHash === blockHead.hash) {\n        return {\n          blockNumber: fromHex(oldLog.blockNumber),\n          logIndex: fromHex(oldLog.logIndex)\n        };\n      }\n    }\n    return {\n      blockNumber: Number.NEGATIVE_INFINITY,\n      logIndex: Number.NEGATIVE_INFINITY\n    };\n  }\n\n  /**\n   * Gets all `logs` events in the provided range. Note that the returned logs\n   * do not include removed logs.\n   *\n   * @private\n   */ private async getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1)\n    };\n    return this.provider.send('eth_getLogs', [rangeFilter]);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, event => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, event => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach(item => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst CANCELLED = new Error('Cancelled');\nexport function throwIfCancelled(isCancelled: () => boolean): void {\n  if (isCancelled()) {\n    throw CANCELLED;\n  }\n}\n","import {\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent\n} from './websocket-backfiller';\nimport { EventType, Filter, Listener } from '@ethersproject/abstract-provider';\n\n/** This file contains internal types used by the SDK and are not exposed to the end user. */\n\ntype JsonRpcId = string | number | null;\n\n/**\n * Prefix for `alchemy_pendingTransactions` subscriptions when serializing to\n * ethers events.\n */\nexport const ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE =\n  'alchemy-pending-transactions';\n\n/** Method name for Alchemy pending transaction subscriptions when using Websockets. */\nexport const ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD =\n  'alchemy_pendingTransactions';\n\nexport interface JsonRpcRequest {\n  jsonrpc: '2.0';\n  method: string;\n  params?: any[];\n  id?: JsonRpcId;\n}\n\nexport interface VirtualSubscription {\n  event: EthersEvent;\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\nexport interface JsonRpcResponse<T = any> {\n  jsonrpc: '2.0';\n  result?: T;\n  error?: JsonRpcError;\n  id: JsonRpcId;\n}\n\ninterface JsonRpcError<T = any> {\n  code: number;\n  message: string;\n  data?: T;\n}\n\nexport interface NewHeadsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['newHeads'];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\nexport interface LogsSubscription extends VirtualSubscription {\n  method: 'eth_subscribe';\n  params: ['logs', LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\nexport type WebSocketMessage = SingleOrBatchResponse | SubscriptionEvent;\nexport type SingleOrBatchResponse = JsonRpcResponse | JsonRpcResponse[];\n\n/**\n * DO NOT MODIFY.\n *\n * Event class copied directly over from ethers.js's `BaseProvider` class.\n *\n * This class is used to represent events and their corresponding listeners. The\n * SDK needs to extend this class in order to support Alchemy's custom\n * Subscription API types. The original class is not exported by ethers. Minimal\n * changes have been made in order to get TS to compile.\n */\nexport class Event {\n  readonly listener: Listener;\n  readonly once: boolean;\n  readonly tag: string;\n\n  _lastBlockNumber: number;\n  _inflight: boolean;\n\n  constructor(tag: string, listener: Listener, once: boolean) {\n    this.listener = listener;\n    this.tag = tag;\n    this.once = once;\n    this._lastBlockNumber = -2;\n    this._inflight = false;\n  }\n\n  get event(): EventType {\n    switch (this.type) {\n      case 'tx':\n        return this.hash!;\n      case 'filter':\n        return this.filter!;\n      default:\n        return this.tag;\n    }\n  }\n\n  get type(): string {\n    return this.tag.split(':')[0];\n  }\n\n  get hash(): string {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'tx') {\n      throw new Error('Not a transaction event');\n    }\n    return comps[1];\n  }\n\n  get filter(): Filter {\n    const comps = this.tag.split(':');\n    if (comps[0] !== 'filter') {\n      throw new Error('Not a transaction event');\n    }\n    const address = comps[1];\n\n    const topics = deserializeTopics(comps[2]);\n    const filter: Filter = {};\n\n    if (topics.length > 0) {\n      filter.topics = topics;\n    }\n    if (address && address !== '*') {\n      filter.address = address;\n    }\n\n    return filter;\n  }\n\n  pollable(): boolean {\n    const PollableEvents = ['block', 'network', 'pending', 'poll'];\n    return this.tag.indexOf(':') >= 0 || PollableEvents.indexOf(this.tag) >= 0;\n  }\n}\n\n/**\n * Wrapper class around the ethers `Event` class in order to add support for\n * Alchemy's custom subscriptions types.\n *\n * The getters on this class deserialize the event tag generated by\n * {@link getAlchemyEventTag} into the original fields passed into the event.\n */\nexport class EthersEvent extends Event {\n  /**\n   * Converts the event tag into the original `fromAddress` field in\n   * {@link AlchemyPendingTransactionsEventFilter}.\n   */\n  get fromAddress(): string | string[] | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[1] && comps[1] !== '*') {\n      return deserializeAddressField(comps[1]);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Converts the event tag into the original `toAddress` field in\n   * {@link AlchemyPendingTransactionsEventFilter}.\n   */\n  get toAddress(): string | string[] | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[2] && comps[2] !== '*') {\n      return deserializeAddressField(comps[2]);\n    } else {\n      return undefined;\n    }\n  }\n\n  /**\n   * Converts the event tag into the original `hashesOnly` field in\n   * {@link AlchemyPendingTransactionsEventFilter}.\n   */\n  get hashesOnly(): boolean | undefined {\n    const comps = this.tag.split(':');\n    if (comps[0] !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      return undefined;\n    }\n    if (comps[3] && comps[3] !== '*') {\n      return comps[3] === 'true';\n    } else {\n      return undefined;\n    }\n  }\n}\n\nexport interface SubscriptionEvent<T = any> {\n  jsonrpc: '2.0';\n  method: 'eth_subscription';\n  params: {\n    subscription: string;\n    result: T;\n  };\n}\n\nfunction deserializeTopics(data: string): any {\n  if (data === '') {\n    return [];\n  }\n\n  return data.split(/&/g).map(topic => {\n    if (topic === '') {\n      return [];\n    }\n\n    const comps = topic.split('|').map(topic => {\n      return topic === 'null' ? null : topic;\n    });\n\n    return comps.length === 1 ? comps[0] : comps;\n  });\n}\n\nfunction deserializeAddressField(data: string): string | string[] | undefined {\n  if (data === '') {\n    return undefined;\n  }\n\n  const addresses = data.split('|');\n  return addresses.length === 1 ? addresses[0] : addresses;\n}\n","import { BigNumber } from '@ethersproject/bignumber';\nimport {\n  CustomNetworks,\n  DEFAULT_ALCHEMY_API_KEY,\n  EthersNetwork,\n  noop\n} from '../util/const';\nimport { AlchemyProvider } from './alchemy-provider';\nimport { Listener } from '@ethersproject/abstract-provider';\nimport {\n  AlchemyEventType,\n  AlchemyPendingTransactionsEventFilter\n} from '../types/types';\nimport {\n  BatchPart,\n  dedupeLogs,\n  dedupeNewHeads,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  NewHeadsEvent,\n  throwIfCancelled,\n  WebsocketBackfiller\n} from '../internal/websocket-backfiller';\nimport { fromHex } from './util';\nimport SturdyWebSocket from 'sturdy-websocket';\nimport { VERSION } from '../version';\nimport {\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD,\n  ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n  EthersEvent,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  LogsSubscription,\n  NewHeadsSubscription,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  VirtualSubscription,\n  WebSocketMessage\n} from '../internal/internal-types';\nimport {\n  CommunityResourcable,\n  WebSocketProvider\n} from '@ethersproject/providers';\nimport { AlchemyConfig } from './alchemy-config';\nimport {\n  getNetwork as getNetworkFromEthers,\n  Networkish\n} from '@ethersproject/networks';\nimport { Network as NetworkFromEthers } from '@ethersproject/networks/lib/types';\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * SDK's custom implementation fo the ethers.js's 'AlchemyWebSocketProvider'.\n *\n * Do not call this constructor directly. Instead, instantiate an instance of\n * {@link Alchemy} and call {@link Alchemy.config.getWebSocketProvider()}.\n *\n * @public\n */\nexport class AlchemyWebSocketProvider\n  extends WebSocketProvider\n  implements CommunityResourcable\n{\n  _events: Array<EthersEvent> = [];\n  readonly apiKey: string;\n\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  /** @internal */\n  private readonly virtualSubscriptionsById: Map<string, VirtualSubscription> =\n    new Map();\n  /** @internal */\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  /** @internal */\n  private readonly backfiller: WebsocketBackfiller;\n  /** @internal */\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  /** @internal */\n  private cancelBackfill: () => void;\n\n  /** @internal */\n  constructor(config: AlchemyConfig, wsConstructor?: any) {\n    // Normalize the API Key to a string.\n    const apiKey = AlchemyProvider.getApiKey(config.apiKey);\n\n    // Generate our own connection info with the correct endpoint URLs.\n    const alchemyNetwork = AlchemyProvider.getAlchemyNetwork(config.network);\n    const connection = AlchemyProvider.getAlchemyConnectionInfo(\n      alchemyNetwork,\n      apiKey,\n      'wss'\n    );\n\n    const protocol = `alchemy-sdk-${VERSION}`;\n\n    // Use the provided config URL override if it exists, otherwise use the created one.\n    const ws = new SturdyWebSocket(config.url ?? connection.url, protocol, {\n      wsConstructor: wsConstructor ?? getWebsocketConstructor()\n    });\n\n    // Normalize the Alchemy named network input to the network names used by\n    // ethers. This allows the parent super constructor in JsonRpcProvider to\n    // correctly set the network.\n    const ethersNetwork = EthersNetwork[alchemyNetwork];\n    super(ws as any, ethersNetwork);\n    this.apiKey = apiKey;\n\n    // Start heartbeat and backfiller for the websocket connection.\n    this.backfiller = new WebsocketBackfiller(this);\n    this.addSocketListeners();\n    this.startHeartbeat();\n    this.cancelBackfill = noop;\n  }\n\n  /**\n   * Overrides the `BaseProvider.getNetwork` method as implemented by ethers.js.\n   *\n   * This override allows the SDK to set the provider's network to values not\n   * yet supported by ethers.js.\n   *\n   * @internal\n   * @override\n   */\n  static getNetwork(network: Networkish): NetworkFromEthers {\n    if (typeof network === 'string' && network in CustomNetworks) {\n      return CustomNetworks[network];\n    }\n\n    // Call the standard ethers.js getNetwork method for other networks.\n    return getNetworkFromEthers(network);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based subscriptions.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  on(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, false);\n  }\n\n  /**\n   * Overridden implementation of ethers that includes Alchemy based\n   * subscriptions. Adds a listener to the triggered for only the next\n   * {@link eventName} event, after which it will be removed.\n   *\n   * @param eventName Event to subscribe to\n   * @param listener The listener function to call when the event is triggered.\n   * @override\n   * @public\n   */\n  // TODO: Override `Listener` type to get type autocompletions.\n  once(eventName: AlchemyEventType, listener: Listener): this {\n    return this._addEventListener(eventName, listener, true);\n  }\n\n  /**\n   * Removes the provided {@link listener} for the {@link eventName} event. If no\n   * listener is provided, all listeners for the event will be removed.\n   *\n   * @param eventName Event to unlisten to.\n   * @param listener The listener function to remove.\n   * @override\n   * @public\n   */\n  off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (isAlchemyEvent(eventName)) {\n      return this._off(eventName, listener);\n    } else {\n      return super.off(eventName, listener);\n    }\n  }\n\n  /**\n   * Remove all listeners for the provided {@link eventName} event. If no event\n   * is provided, all events and their listeners are removed.\n   *\n   * @param eventName The event to remove all listeners for.\n   * @override\n   * @public\n   */\n  removeAllListeners(eventName?: AlchemyEventType): this {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._removeAllListeners(eventName);\n    } else {\n      return super.removeAllListeners(eventName);\n    }\n  }\n\n  /**\n   * Returns the number of listeners for the provided {@link eventName} event. If\n   * no event is provided, the total number of listeners for all events is returned.\n   *\n   * @param eventName The event to get the number of listeners for.\n   * @public\n   * @override\n   */\n  listenerCount(eventName?: AlchemyEventType): number {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listenerCount(eventName);\n    } else {\n      return super.listenerCount(eventName);\n    }\n  }\n\n  /**\n   * Returns an array of listeners for the provided {@link eventName} event. If\n   * no event is provided, all listeners will be included.\n   *\n   * @param eventName The event to get the listeners for.\n   * @public\n   * @override\n   */\n  listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName !== undefined && isAlchemyEvent(eventName)) {\n      return this._listeners(eventName);\n    } else {\n      return super.listeners(eventName);\n    }\n  }\n\n  /**\n   * Overrides the method in `BaseProvider` in order to properly format the\n   * Alchemy subscription events.\n   *\n   * @internal\n   * @override\n   */\n  _addEventListener(\n    eventName: AlchemyEventType,\n    listener: Listener,\n    once: boolean\n  ): this {\n    if (isAlchemyEvent(eventName)) {\n      verifyAlchemyEventName(eventName);\n      const event = new EthersEvent(\n        getAlchemyEventTag(eventName),\n        listener,\n        once\n      );\n      this._events.push(event);\n      this._startEvent(event);\n      return this;\n    } else {\n      return super._addEventListener(eventName, listener, once);\n    }\n  }\n\n  /**\n   * Overrides the `_startEvent()` method in ethers.js's\n   * {@link WebSocketProvider} to include additional alchemy methods.\n   *\n   * @param event\n   * @override\n   * @internal\n   */\n  _startEvent(event: EthersEvent): void {\n    // Check if the event type is a custom Alchemy subscription.\n    const customLogicTypes = [\n      ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE,\n      'block',\n      'filter'\n    ];\n    if (customLogicTypes.includes(event.type)) {\n      this.customStartEvent(event);\n    } else {\n      super._startEvent(event);\n    }\n  }\n\n  /**\n   * Overridden from ethers.js's {@link WebSocketProvider}\n   *\n   * Modified in order to add mappings for backfilling.\n   *\n   * @internal\n   * @override\n   */\n  async _subscribe(\n    tag: string,\n    param: Array<any>,\n    processFunc: (result: any) => void,\n    event?: EthersEvent\n  ): Promise<void> {\n    let subIdPromise = this._subIds[tag];\n\n    // BEGIN MODIFIED CODE\n    const startingBlockNumber = await this.getBlockNumber();\n    // END MODIFIED CODE\n\n    if (subIdPromise == null) {\n      subIdPromise = Promise.all(param).then(param => {\n        return this.send('eth_subscribe', param);\n      });\n      this._subIds[tag] = subIdPromise;\n    }\n    const subId = await subIdPromise;\n\n    // BEGIN MODIFIED CODE\n    const resolvedParams = await Promise.all(param);\n    this.virtualSubscriptionsById.set(subId, {\n      event: event!,\n      method: 'eth_subscribe',\n      params: resolvedParams,\n      startingBlockNumber,\n      virtualId: subId,\n      physicalId: subId,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: []\n    });\n    this.virtualIdsByPhysicalId.set(subId, subId);\n\n    // END MODIFIED CODE\n\n    this._subs[subId] = { tag, processFunc };\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @internal\n   * @override\n   */\n  emit(eventName: AlchemyEventType, ...args: Array<any>): boolean {\n    if (isAlchemyEvent(eventName)) {\n      let result = false;\n\n      const stopped: Array<EthersEvent> = [];\n\n      // This line is the only modified line from the original method.\n      const eventTag = getAlchemyEventTag(eventName);\n\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n\n        setTimeout(() => {\n          event.listener.apply(this, args);\n        }, 0);\n\n        result = true;\n\n        if (event.once) {\n          stopped.push(event);\n          return false;\n        }\n\n        return true;\n      });\n\n      stopped.forEach(event => {\n        this._stopEvent(event);\n      });\n\n      return result;\n    } else {\n      return super.emit(eventName, ...args);\n    }\n  }\n\n  /** @internal */\n  async sendBatch(parts: BatchPart[]): Promise<any[]> {\n    let nextId = 0;\n    const payload: JsonRpcRequest[] = parts.map(({ method, params }) => {\n      return {\n        method,\n        params,\n        jsonrpc: '2.0',\n        id: `alchemy-sdk:${nextId++}`\n      };\n    });\n\n    const response = await this.sendBatchConcurrently(payload);\n    const errorResponse = response.find(r => !!r.error);\n    if (errorResponse) {\n      throw new Error(errorResponse.error!.message);\n    }\n    // The ids are ascending numbers because that's what Payload Factories do.\n    return response\n      .sort((r1, r2) => (r1.id as number) - (r2.id as number))\n      .map(r => r.result);\n  }\n\n  /** @override */\n  destroy(): Promise<void> {\n    this.removeSocketListeners();\n    this.stopHeartbeatAndBackfill();\n    return super.destroy();\n  }\n\n  /**\n   * Overrides the ether's `isCommunityResource()` method. Returns true if the\n   * current api key is the default key.\n   *\n   * @override\n   */\n  isCommunityResource(): boolean {\n    return this.apiKey === DEFAULT_ALCHEMY_API_KEY;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `WebSocketProvider._stopEvent()`.\n   *\n   * This method is copied over directly in order to support Alchemy's\n   * subscription type by allowing the provider to properly stop Alchemy's\n   * subscription events.\n   *\n   * @internal\n   */\n  _stopEvent(event: EthersEvent): void {\n    let tag = event.tag;\n\n    // START MODIFIED CODE\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      // There are remaining pending transaction listeners.\n      if (\n        this._events.filter(\n          e => e.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE\n        ).length\n      ) {\n        return;\n      }\n      // END MODIFIED CODE\n    } else if (event.type === 'tx') {\n      // There are remaining transaction event listeners\n      if (this._events.filter(e => e.type === 'tx').length) {\n        return;\n      }\n      tag = 'tx';\n    } else if (this.listenerCount(event.event)) {\n      // There are remaining event listeners\n      return;\n    }\n\n    const subId = this._subIds[tag];\n    if (!subId) {\n      return;\n    }\n\n    delete this._subIds[tag];\n    void subId.then(subId => {\n      if (!this._subs[subId]) {\n        return;\n      }\n      delete this._subs[subId];\n      void this.send('eth_unsubscribe', [subId]);\n    });\n  }\n\n  /** @internal */\n  private addSocketListeners(): void {\n    this._websocket.addEventListener('message', this.handleMessage);\n    this._websocket.addEventListener('reopen', this.handleReopen);\n    this._websocket.addEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /** @internal */\n  private removeSocketListeners(): void {\n    this._websocket.removeEventListener('message', this.handleMessage);\n    this._websocket.removeEventListener('reopen', this.handleReopen);\n    this._websocket.removeEventListener('down', this.stopHeartbeatAndBackfill);\n  }\n\n  /**\n   * The underlying ethers {@link WebSocketProvider} already handles and emits\n   * messages. To allow backfilling, track all messages that are emitted.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== 'eth_subscribe') {\n      return;\n    }\n\n    switch (subscription.params[0]) {\n      case 'newHeads': {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else if (physicalId !== virtualId) {\n          // In the case of a re-opened subscription, ethers will not emit the\n          // event, so the SDK has to.\n          this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        } else {\n          // Ethers subscription mapping will emit the event, just store it.\n          this.rememberEvent(virtualId, result, getNewHeadsBlockNumber);\n        }\n        break;\n      }\n      case 'logs': {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else if (virtualId !== physicalId) {\n          this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n        } else {\n          this.rememberEvent(virtualId, result, getLogsBlockNumber);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  };\n\n  /**\n   * When the websocket connection reopens:\n   *\n   * 1. Resubscribe to all existing subscriptions and start backfilling\n   * 2. Restart heart beat.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private handleReopen = () => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      void (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  /**\n   * Reopens the backfill based on\n   *\n   * @param isCancelled\n   * @param subscription\n   * @internal\n   */\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case 'newHeads': {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case 'logs': {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber\n                ),\n                BACKFILL_TIMEOUT\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled()\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  /**\n   * Cancels the heartbeat and any pending backfills being performed. This is\n   * called when the websocket connection goes down or is disconnected.\n   *\n   * This is a field arrow function in order to preserve `this` context when\n   * passing the method as an event listener.\n   *\n   * @internal\n   */\n  private stopHeartbeatAndBackfill = () => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  /** @internal */\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  /** @internal */\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   *\n   * @internal\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    this.rememberEvent(virtualId, result, getBlockNumber);\n\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    this.emitGenericEvent(subscription, result);\n  }\n\n  /** @internal */\n  private rememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber\n    );\n  }\n\n  /** @internal */\n  private emitGenericEvent(\n    subscription: VirtualSubscription,\n    result: any\n  ): void {\n    const emitFunction = this.emitProcessFn(subscription.event);\n    emitFunction(result);\n  }\n\n  /**\n   * Starts a heartbeat that pings the websocket server periodically to ensure\n   * that the connection stays open.\n   *\n   * @internal\n   */\n  private startHeartbeat(): void {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send('net_version'), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this._websocket.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  }\n\n  /**\n   * This method sends the batch concurrently as individual requests rather than\n   * as a batch, which was the original implementation. The original batch logic\n   * is preserved in this implementation in order for faster porting.\n   *\n   * @param payload\n   * @internal\n   */\n  // TODO(cleanup): Refactor and remove usages of `sendBatch()`.\n  // TODO(errors): Use allSettled() once we have more error handling.\n  private async sendBatchConcurrently(\n    payload: JsonRpcRequest[]\n  ): Promise<JsonRpcResponse[]> {\n    return Promise.all(payload.map(req => this.send(req.method, req.params)));\n  }\n\n  /** @internal */\n  private customStartEvent(event: EthersEvent): void {\n    if (event.type === ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE) {\n      const { fromAddress, toAddress, hashesOnly } = event;\n      void this._subscribe(\n        event.tag,\n        [\n          ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD,\n          { fromAddress, toAddress, hashesOnly }\n        ],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'block') {\n      void this._subscribe(\n        'block',\n        ['newHeads'],\n        this.emitProcessFn(event),\n        event\n      );\n    } else if (event.type === 'filter') {\n      void this._subscribe(\n        event.tag,\n        ['logs', this._getFilter(event.filter)],\n        this.emitProcessFn(event),\n        event\n      );\n    }\n  }\n\n  /** @internal */\n  private emitProcessFn(event: EthersEvent): (result: any) => void {\n    switch (event.type) {\n      case ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE:\n        const { fromAddress, toAddress, hashesOnly } = event;\n        return result =>\n          this.emit(\n            {\n              method: ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD,\n              fromAddress,\n              toAddress,\n              hashesOnly\n            },\n            result\n          );\n      case 'block':\n        return result => {\n          const blockNumber = BigNumber.from(result.number).toNumber();\n          this._emitted.block = blockNumber;\n          this.emit('block', blockNumber);\n        };\n      case 'filter':\n        return result => {\n          if (result.removed == null) {\n            result.removed = false;\n          }\n          this.emit(event.filter, this.formatter.filterLog(result));\n        };\n      default:\n        throw new Error('Invalid event type to `emitProcessFn()`');\n    }\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.off()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _off(eventName: AlchemyEventType, listener?: Listener): this {\n    if (listener == null) {\n      return this.removeAllListeners(eventName);\n    }\n\n    const stopped: Array<EthersEvent> = [];\n\n    let found = false;\n    const eventTag = getAlchemyEventTag(eventName);\n    this._events = this._events.filter(event => {\n      if (event.tag !== eventTag || event.listener != listener) {\n        return true;\n      }\n      if (found) {\n        return true;\n      }\n      found = true;\n      stopped.push(event);\n      return false;\n    });\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.removeAllListeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _removeAllListeners(eventName: AlchemyEventType): this {\n    let stopped: Array<EthersEvent> = [];\n    if (eventName == null) {\n      stopped = this._events;\n\n      this._events = [];\n    } else {\n      const eventTag = getAlchemyEventTag(eventName);\n      this._events = this._events.filter(event => {\n        if (event.tag !== eventTag) {\n          return true;\n        }\n        stopped.push(event);\n        return false;\n      });\n    }\n\n    stopped.forEach(event => {\n      this._stopEvent(event);\n    });\n\n    return this;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listenerCount()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listenerCount(eventName?: AlchemyEventType): number {\n    if (!eventName) {\n      return this._events.length;\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events.filter(event => {\n      return event.tag === eventTag;\n    }).length;\n  }\n\n  /**\n   * DO NOT MODIFY.\n   *\n   * Original code copied over from ether.js's `BaseProvider.listeners()`.\n   *\n   * This method is copied over directly in order to implement Alchemy's unique\n   * subscription types. The only difference is that this method calls\n   * {@link getAlchemyEventTag} instead of the original `getEventTag()` method in\n   * order to parse the Alchemy subscription event.\n   *\n   * @private\n   */\n  private _listeners(eventName?: AlchemyEventType): Array<Listener> {\n    if (eventName == null) {\n      return this._events.map(event => event.listener);\n    }\n\n    const eventTag = getAlchemyEventTag(eventName);\n    return this._events\n      .filter(event => event.tag === eventTag)\n      .map(event => event.listener);\n  }\n}\n\nfunction getWebsocketConstructor(): any {\n  return isNodeEnvironment() ? require('websocket').w3cwebsocket : WebSocket;\n}\n\nfunction isNodeEnvironment(): boolean {\n  return (\n    typeof process !== 'undefined' &&\n    process != null &&\n    process.versions != null &&\n    process.versions.node != null\n  );\n}\n\n/** @internal */\ninterface CancelToken {\n  cancel(): void;\n  isCancelled(): boolean;\n}\n\n// TODO(cleanup): Use class variable rather than passing `isCancelled` everywhere.\nfunction makeCancelToken(): CancelToken {\n  let cancelled = false;\n  return { cancel: () => (cancelled = true), isCancelled: () => cancelled };\n}\n\n// TODO(cleanup): replace with SDK's backoff implementation\nconst MIN_RETRY_DELAY = 1000;\nconst RETRY_BACKOFF_FACTOR = 2;\nconst MAX_RETRY_DELAY = 30000;\n\nasync function withBackoffRetries<T>(\n  f: () => Promise<T>,\n  retryCount: number,\n  shouldRetry: (error: unknown) => boolean = () => true\n): Promise<T> {\n  let nextWaitTime = 0;\n  let i = 0;\n  while (true) {\n    try {\n      return await f();\n    } catch (error) {\n      i++;\n      if (i >= retryCount || !shouldRetry(error)) {\n        throw error;\n      }\n      await delay(nextWaitTime);\n      if (!shouldRetry(error)) {\n        throw error;\n      }\n      nextWaitTime =\n        nextWaitTime === 0\n          ? MIN_RETRY_DELAY\n          : Math.min(MAX_RETRY_DELAY, RETRY_BACKOFF_FACTOR * nextWaitTime);\n    }\n  }\n}\n\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nfunction withTimeout<T>(promise: Promise<T>, ms: number): Promise<T> {\n  return Promise.race([\n    promise,\n    new Promise<T>((_, reject) =>\n      setTimeout(() => reject(new Error('Timeout')), ms)\n    )\n  ]);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction isResponse(\n  message: WebSocketMessage\n): message is SingleOrBatchResponse {\n  return (\n    Array.isArray(message) ||\n    (message.jsonrpc === '2.0' && (message as JsonRpcResponse).id !== undefined)\n  );\n}\n\nfunction isSubscriptionEvent(\n  message: WebSocketMessage\n): message is SubscriptionEvent {\n  return !isResponse(message);\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which are so old\n * that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n\nfunction isAlchemyEvent(\n  event: AlchemyEventType\n): event is AlchemyPendingTransactionsEventFilter {\n  return typeof event === 'object' && 'method' in event;\n}\n\n/**\n * Creates a string representation of an `alchemy_pendingTransaction`\n * subscription filter that is compatible with the ethers implementation of\n * `getEventTag()`. The method is not an exported function in ethers, which is\n * why the SDK has its own implementation.\n *\n * The event tag is then deserialized by the SDK's {@link EthersEvent} getters.\n *\n * @example\n *   ```js\n *   // Returns 'alchemy-pending-transactions:0xABC:0xDEF|0xGHI:true'\n *   const eventTag =  getAlchemyEventTag(\n *   {\n *     \"method\": \"alchemy_pendingTransaction\",\n *     \"fromAddress\": \"0xABC\",\n *     \"toAddress\": [\"0xDEF\", \"0xGHI\"],\n *     \"hashesOnly: true\n *   });\n *   ```;\n *\n * @param event\n * @internal\n */\nexport function getAlchemyEventTag(event: AlchemyEventType): string {\n  if (!isAlchemyEvent(event)) {\n    throw new Error('Event tag requires AlchemyEventType');\n  }\n  const fromAddress = serializeAddressField(event.fromAddress);\n  const toAddress = serializeAddressField(event.toAddress);\n  const hashesOnly = serializeBooleanField(event.hashesOnly);\n  return (\n    ALCHEMY_PENDING_TRANSACTIONS_EVENT_TYPE +\n    ':' +\n    fromAddress +\n    ':' +\n    toAddress +\n    ':' +\n    hashesOnly\n  );\n}\n\nfunction serializeAddressField(\n  field: string | Array<string> | undefined\n): string {\n  if (field === undefined) {\n    return '*';\n  } else if (Array.isArray(field)) {\n    return field.join('|');\n  } else {\n    return field;\n  }\n}\n\nfunction serializeBooleanField(field: boolean | undefined): string | undefined {\n  if (field === undefined) {\n    return '*';\n  } else {\n    return field.toString();\n  }\n}\n\nfunction verifyAlchemyEventName(\n  eventName: AlchemyPendingTransactionsEventFilter\n): void {\n  if (eventName.method !== ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD) {\n    throw new Error(\n      `Invalid method name ${eventName.method}. Accepted method names: ${ALCHEMY_PENDING_TRANSACTIONS_EVENT_METHOD}`\n    );\n  }\n}\n","export interface Options {\n    allClearResetTime?: number;\n    connectTimeout?: number;\n    debug?: boolean;\n    minReconnectDelay?: number;\n    maxReconnectDelay?: number;\n    maxReconnectAttempts?: number;\n    reconnectBackoffFactor?: number;\n    wsConstructor?: new (url: string, protocols?: string | string[]) => any;\n    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;\n}\n\ninterface SturdyWebSocketEventMap extends WebSocketEventMap {\n    down: CloseEvent;\n    reopen: Event;\n}\n\ntype WebSocketListener<K extends keyof SturdyWebSocketEventMap> = (\n    this: WebSocket,\n    event: SturdyWebSocketEventMap[K],\n) => any;\n\ntype WebSocketListeners = {\n    [K in keyof SturdyWebSocketEventMap]?: Array<WebSocketListener<K>>;\n} & {\n    [key: string]: EventListenerOrEventListenerObject[];\n};\n\nconst SHOULD_RECONNECT_FALSE_MESSAGE =\n    \"Provided shouldReconnect() returned false. Closing permanently.\";\nconst SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE =\n    \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nexport default class SturdyWebSocket implements WebSocket {\n    public static readonly DEFAULT_OPTIONS: Required<Options> = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: () => true,\n        wsConstructor: undefined!,\n    };\n\n    public static readonly CONNECTING = 0;\n    public static readonly OPEN = 1;\n    public static readonly CLOSING = 2;\n    public static readonly CLOSED = 3;\n\n    public onclose: ((event: CloseEvent) => void) | null = null;\n    public onerror: ((event: Event) => void) | null = null;\n    public onmessage: ((event: MessageEvent) => void) | null = null;\n    public onopen: ((event: Event) => void) | null = null;\n    public ondown: ((event: CloseEvent | undefined) => void) | null = null;\n    public onreopen: ((event: Event) => void) | null = null;\n    public readonly CONNECTING = SturdyWebSocket.CONNECTING;\n    public readonly OPEN = SturdyWebSocket.OPEN;\n    public readonly CLOSING = SturdyWebSocket.CLOSING;\n    public readonly CLOSED = SturdyWebSocket.CLOSED;\n\n    private readonly protocols?: string | string[];\n    private readonly options: Required<Options>;\n    private ws?: WebSocket;\n    private hasBeenOpened = false;\n    private isClosed = false;\n    private messageBuffer: any[] = [];\n    private nextRetryTime: number = 0;\n    private reconnectCount = 0;\n    private allClearTimeoutId?: any;\n    private connectTimeoutId?: any;\n    private binaryTypeInternal?: BinaryType;\n    private lastKnownExtensions = \"\";\n    private lastKnownProtocol = \"\";\n    private readonly listeners: WebSocketListeners = {};\n\n    constructor(url: string, options?: Options);\n    constructor(\n        url: string,\n        protocols: string | string[] | undefined,\n        options?: Options,\n    );\n    constructor(\n        public readonly url: string,\n        protocolsOrOptions?: string | string[] | Options,\n        options: Options = {},\n    ) {\n        if (\n            protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)\n        ) {\n            this.protocols = protocolsOrOptions;\n        } else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            } else {\n                throw new Error(\n                    \"WebSocket not present in global scope and no \" +\n                        \"wsConstructor option was provided.\",\n                );\n            }\n        }\n        this.openNewWebSocket();\n    }\n\n    public get binaryType(): BinaryType {\n        return this.binaryTypeInternal || \"blob\";\n    }\n\n    public set binaryType(binaryType: BinaryType) {\n        this.binaryTypeInternal = binaryType;\n        if (this.ws) {\n            this.ws.binaryType = binaryType;\n        }\n    }\n\n    public get bufferedAmount(): number {\n        let sum = this.ws ? this.ws.bufferedAmount : 0;\n        let hasUnknownAmount = false;\n        this.messageBuffer.forEach(data => {\n            const byteLength = getDataByteLength(data);\n            if (byteLength != null) {\n                sum += byteLength;\n            } else {\n                hasUnknownAmount = true;\n            }\n        });\n        if (hasUnknownAmount) {\n            this.debugLog(\n                \"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\",\n            );\n        }\n        return sum;\n    }\n\n    public get extensions(): string {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    }\n\n    public get protocol(): string {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    }\n\n    public get readyState(): number {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    }\n\n    public close(code?: number, reason?: string): void {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    }\n\n    public send(data: any): void {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        } else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.messageBuffer.push(data);\n        }\n    }\n\n    public reconnect(): void {\n        if (this.isClosed) {\n            throw new Error(\n                \"Cannot call reconnect() on socket which is permanently closed.\",\n            );\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    }\n\n    public addEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return this.dispatchEventOfType(event.type, event);\n    }\n\n    public removeEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(\n                l => l !== listener,\n            );\n        }\n    }\n\n    private openNewWebSocket(): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { connectTimeout, wsConstructor } = this.options;\n        this.debugLog(`Opening new WebSocket to ${this.url}.`);\n        const ws: WebSocket = new wsConstructor(this.url, this.protocols);\n        ws.onclose = event => this.handleClose(event);\n        ws.onerror = event => this.handleError(event);\n        ws.onmessage = event => this.handleMessage(event);\n        ws.onopen = event => this.handleOpen(event);\n        this.connectTimeoutId = setTimeout(() => {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            this.clearConnectTimeout();\n            this.disposeSocket();\n            this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    }\n\n    private handleOpen(event: Event): void {\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        const { allClearResetTime } = this.options;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        } else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        } else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(message => this.send(message));\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(() => {\n            this.clearAllClearTimeout();\n            this.nextRetryTime = 0;\n            this.reconnectCount = 0;\n            const openTime = (allClearResetTime / 1000) | 0;\n            this.debugLog(\n                `WebSocket remained open for ${openTime} seconds. Resetting` +\n                    \" retry time and count.\",\n            );\n        }, allClearResetTime);\n    }\n\n    private handleMessage(event: MessageEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    }\n\n    private handleClose(event: CloseEvent | undefined): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { maxReconnectAttempts, shouldReconnect } = this.options;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(\n                event,\n                this.getTooManyFailedReconnectsMessage(),\n            );\n            return;\n        }\n        const willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(\n                willReconnect,\n                event,\n                SHOULD_RECONNECT_FALSE_MESSAGE,\n            );\n        } else {\n            willReconnect.then(willReconnectResolved => {\n                if (this.isClosed) {\n                    return;\n                }\n                this.handleWillReconnect(\n                    willReconnectResolved,\n                    event,\n                    SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE,\n                );\n            });\n        }\n    }\n\n    private handleError(event: Event): void {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    }\n\n    private handleWillReconnect(\n        willReconnect: boolean,\n        event: CloseEvent | undefined,\n        denialReason: string,\n    ): void {\n        if (willReconnect) {\n            this.reestablishConnection();\n        } else {\n            this.stopReconnecting(event, denialReason);\n        }\n    }\n\n    private reestablishConnection(): void {\n        const {\n            minReconnectDelay,\n            maxReconnectDelay,\n            reconnectBackoffFactor,\n        } = this.options;\n        this.reconnectCount++;\n        const retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(\n            minReconnectDelay,\n            Math.min(\n                this.nextRetryTime * reconnectBackoffFactor,\n                maxReconnectDelay,\n            ),\n        );\n        setTimeout(() => this.openNewWebSocket(), retryTime);\n        const retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\n            `WebSocket was closed. Re-opening in ${retryTimeSeconds} seconds.`,\n        );\n    }\n\n    private stopReconnecting(\n        event: CloseEvent | undefined,\n        debugReason: string,\n    ): void {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    }\n\n    private shutdown(): void {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    }\n\n    private disposeSocket(closeCode?: number, reason?: string): void {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    }\n\n    private clearAllTimeouts(): void {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    }\n\n    private clearConnectTimeout(): void {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    }\n\n    private clearAllClearTimeout(): void {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    }\n\n    private dispatchEventOfType(type: string, event: any): boolean {\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(listener => this.callListener(listener, event));\n        }\n        return !event || !(event as Event).defaultPrevented;\n    }\n\n    private callListener(\n        listener: EventListenerOrEventListenerObject,\n        event: Event,\n    ): void {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        } else {\n            listener.handleEvent.call(this, event);\n        }\n    }\n\n    private debugLog(message: string): void {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    }\n\n    private getTooManyFailedReconnectsMessage(): string {\n        const { maxReconnectAttempts } = this.options;\n        return `Failed to reconnect after ${maxReconnectAttempts} ${pluralize(\n            \"attempt\",\n            maxReconnectAttempts,\n        )}. Closing permanently.`;\n    }\n}\n\nfunction applyDefaultOptions(options: Options): Required<Options> {\n    const result: any = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(key => {\n        const value = (options as any)[key];\n        result[key] =\n            value === undefined\n                ? (SturdyWebSocket.DEFAULT_OPTIONS as any)[key]\n                : value;\n    });\n    return result;\n}\n\nfunction getDataByteLength(data: any): number | undefined {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    } else if (data instanceof Blob) {\n        return data.size;\n    } else {\n        return undefined;\n    }\n}\n\nfunction pluralize(s: string, n: number): string {\n    return n === 1 ? s : `${s}s`;\n}\n\nfunction noop(): void {\n    // Nothing.\n}\n","var _globalThis;\nif (typeof globalThis === 'object') {\n\t_globalThis = globalThis;\n} else {\n\ttry {\n\t\t_globalThis = require('es5-ext/global');\n\t} catch (error) {\n\t} finally {\n\t\tif (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }\n\t\tif (!_globalThis) { throw new Error('Could not determine global this'); }\n\t}\n}\n\nvar NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;\nvar websocket_version = require('./version');\n\n\n/**\n * Expose a W3C WebSocket class with just one or two arguments.\n */\nfunction W3CWebSocket(uri, protocols) {\n\tvar native_instance;\n\n\tif (protocols) {\n\t\tnative_instance = new NativeWebSocket(uri, protocols);\n\t}\n\telse {\n\t\tnative_instance = new NativeWebSocket(uri);\n\t}\n\n\t/**\n\t * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket\n\t * class). Since it is an Object it will be returned as it is when creating an\n\t * instance of W3CWebSocket via 'new W3CWebSocket()'.\n\t *\n\t * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2\n\t */\n\treturn native_instance;\n}\nif (NativeWebSocket) {\n\t['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {\n\t\tObject.defineProperty(W3CWebSocket, prop, {\n\t\t\tget: function() { return NativeWebSocket[prop]; }\n\t\t});\n\t});\n}\n\n/**\n * Module exports.\n */\nmodule.exports = {\n    'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,\n    'version'      : websocket_version\n};\n","var naiveFallback = function () {\n\tif (typeof self === \"object\" && self) return self;\n\tif (typeof window === \"object\" && window) return window;\n\tthrow new Error(\"Unable to resolve global `this`\");\n};\n\nmodule.exports = (function () {\n\tif (this) return this;\n\n\t// Unexpected strict mode (may happen if e.g. bundled into ESM module)\n\n\t// Fallback to standard globalThis if available\n\tif (typeof globalThis === \"object\" && globalThis) return globalThis;\n\n\t// Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis\n\t// In all ES5+ engines global object inherits from Object.prototype\n\t// (if you approached one that doesn't please report)\n\ttry {\n\t\tObject.defineProperty(Object.prototype, \"__global__\", {\n\t\t\tget: function () { return this; },\n\t\t\tconfigurable: true\n\t\t});\n\t} catch (error) {\n\t\t// Unfortunate case of updates to Object.prototype being restricted\n\t\t// via preventExtensions, seal or freeze\n\t\treturn naiveFallback();\n\t}\n\ttry {\n\t\t// Safari case (window.__global__ works, but __global__ does not)\n\t\tif (!__global__) return naiveFallback();\n\t\treturn __global__;\n\t} finally {\n\t\tdelete Object.prototype.__global__;\n\t}\n})();\n","module.exports = require('../package.json').version;\n","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nlet WS = null;\ntry {\n    WS = WebSocket;\n    if (WS == null) {\n        throw new Error(\"inject please\");\n    }\n}\ncatch (error) {\n    const logger = new Logger(version);\n    WS = function () {\n        logger.throwError(\"WebSockets not supported in this environment\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"new WebSocket()\"\n        });\n    };\n}\n//export default WS;\n//module.exports = WS;\nexport { WS as WebSocket };\n//# sourceMappingURL=ws.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\nimport { WebSocket } from \"./ws\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n/**\n *  Notes:\n *\n *  This provider differs a bit from the polling providers. One main\n *  difference is how it handles consistency. The polling providers\n *  will stall responses to ensure a consistent state, while this\n *  WebSocket provider assumes the connected backend will manage this.\n *\n *  For example, if a polling provider emits an event which indicates\n *  the event occurred in blockhash XXX, a call to fetch that block by\n *  its hash XXX, if not present will retry until it is present. This\n *  can occur when querying a pool of nodes that are mildly out of sync\n *  with each other.\n */\nlet NextId = 1;\n// For more info about the Real-time Event API see:\n//   https://geth.ethereum.org/docs/rpc/pubsub\nexport class WebSocketProvider extends JsonRpcProvider {\n    constructor(url, network) {\n        // This will be added in the future; please open an issue to expedite\n        if (network === \"any\") {\n            logger.throwError(\"WebSocketProvider does not support 'any' network yet\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"network:any\"\n            });\n        }\n        if (typeof (url) === \"string\") {\n            super(url, network);\n        }\n        else {\n            super(\"_websocket\", network);\n        }\n        this._pollingInterval = -1;\n        this._wsReady = false;\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"_websocket\", new WebSocket(this.connection.url));\n        }\n        else {\n            defineReadOnly(this, \"_websocket\", url);\n        }\n        defineReadOnly(this, \"_requests\", {});\n        defineReadOnly(this, \"_subs\", {});\n        defineReadOnly(this, \"_subIds\", {});\n        defineReadOnly(this, \"_detectNetwork\", super.detectNetwork());\n        // Stall sending requests until the socket is open...\n        this.websocket.onopen = () => {\n            this._wsReady = true;\n            Object.keys(this._requests).forEach((id) => {\n                this.websocket.send(this._requests[id].payload);\n            });\n        };\n        this.websocket.onmessage = (messageEvent) => {\n            const data = messageEvent.data;\n            const result = JSON.parse(data);\n            if (result.id != null) {\n                const id = String(result.id);\n                const request = this._requests[id];\n                delete this._requests[id];\n                if (result.result !== undefined) {\n                    request.callback(null, result.result);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: JSON.parse(request.payload),\n                        response: result.result,\n                        provider: this\n                    });\n                }\n                else {\n                    let error = null;\n                    if (result.error) {\n                        error = new Error(result.error.message || \"unknown error\");\n                        defineReadOnly(error, \"code\", result.error.code || null);\n                        defineReadOnly(error, \"response\", data);\n                    }\n                    else {\n                        error = new Error(\"unknown error\");\n                    }\n                    request.callback(error, undefined);\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: JSON.parse(request.payload),\n                        provider: this\n                    });\n                }\n            }\n            else if (result.method === \"eth_subscription\") {\n                // Subscription...\n                const sub = this._subs[result.params.subscription];\n                if (sub) {\n                    //this.emit.apply(this,                  );\n                    sub.processFunc(result.params.result);\n                }\n            }\n            else {\n                console.warn(\"this should not happen\");\n            }\n        };\n        // This Provider does not actually poll, but we want to trigger\n        // poll events for things that depend on them (like stalling for\n        // block and transaction lookups)\n        const fauxPoll = setInterval(() => {\n            this.emit(\"poll\");\n        }, 1000);\n        if (fauxPoll.unref) {\n            fauxPoll.unref();\n        }\n    }\n    // Cannot narrow the type of _websocket, as that is not backwards compatible\n    // so we add a getter and let the WebSocket be a public API.\n    get websocket() { return this._websocket; }\n    detectNetwork() {\n        return this._detectNetwork;\n    }\n    get pollingInterval() {\n        return 0;\n    }\n    resetEventsBlock(blockNumber) {\n        logger.throwError(\"cannot reset events block on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"resetEventBlock\"\n        });\n    }\n    set pollingInterval(value) {\n        logger.throwError(\"cannot set polling interval on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPollingInterval\"\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return null;\n        });\n    }\n    set polling(value) {\n        if (!value) {\n            return;\n        }\n        logger.throwError(\"cannot set polling on WebSocketProvider\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"setPolling\"\n        });\n    }\n    send(method, params) {\n        const rid = NextId++;\n        return new Promise((resolve, reject) => {\n            function callback(error, result) {\n                if (error) {\n                    return reject(error);\n                }\n                return resolve(result);\n            }\n            const payload = JSON.stringify({\n                method: method,\n                params: params,\n                id: rid,\n                jsonrpc: \"2.0\"\n            });\n            this.emit(\"debug\", {\n                action: \"request\",\n                request: JSON.parse(payload),\n                provider: this\n            });\n            this._requests[String(rid)] = { callback, payload };\n            if (this._wsReady) {\n                this.websocket.send(payload);\n            }\n        });\n    }\n    static defaultUrl() {\n        return \"ws:/\\/localhost:8546\";\n    }\n    _subscribe(tag, param, processFunc) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let subIdPromise = this._subIds[tag];\n            if (subIdPromise == null) {\n                subIdPromise = Promise.all(param).then((param) => {\n                    return this.send(\"eth_subscribe\", param);\n                });\n                this._subIds[tag] = subIdPromise;\n            }\n            const subId = yield subIdPromise;\n            this._subs[subId] = { tag, processFunc };\n        });\n    }\n    _startEvent(event) {\n        switch (event.type) {\n            case \"block\":\n                this._subscribe(\"block\", [\"newHeads\"], (result) => {\n                    const blockNumber = BigNumber.from(result.number).toNumber();\n                    this._emitted.block = blockNumber;\n                    this.emit(\"block\", blockNumber);\n                });\n                break;\n            case \"pending\":\n                this._subscribe(\"pending\", [\"newPendingTransactions\"], (result) => {\n                    this.emit(\"pending\", result);\n                });\n                break;\n            case \"filter\":\n                this._subscribe(event.tag, [\"logs\", this._getFilter(event.filter)], (result) => {\n                    if (result.removed == null) {\n                        result.removed = false;\n                    }\n                    this.emit(event.filter, this.formatter.filterLog(result));\n                });\n                break;\n            case \"tx\": {\n                const emitReceipt = (event) => {\n                    const hash = event.hash;\n                    this.getTransactionReceipt(hash).then((receipt) => {\n                        if (!receipt) {\n                            return;\n                        }\n                        this.emit(hash, receipt);\n                    });\n                };\n                // In case it is already mined\n                emitReceipt(event);\n                // To keep things simple, we start up a single newHeads subscription\n                // to keep an eye out for transactions we are watching for.\n                // Starting a subscription for an event (i.e. \"tx\") that is already\n                // running is (basically) a nop.\n                this._subscribe(\"tx\", [\"newHeads\"], (result) => {\n                    this._events.filter((e) => (e.type === \"tx\")).forEach(emitReceipt);\n                });\n                break;\n            }\n            // Nothing is needed\n            case \"debug\":\n            case \"poll\":\n            case \"willPoll\":\n            case \"didPoll\":\n            case \"error\":\n                break;\n            default:\n                console.log(\"unhandled:\", event);\n                break;\n        }\n    }\n    _stopEvent(event) {\n        let tag = event.tag;\n        if (event.type === \"tx\") {\n            // There are remaining transaction event listeners\n            if (this._events.filter((e) => (e.type === \"tx\")).length) {\n                return;\n            }\n            tag = \"tx\";\n        }\n        else if (this.listenerCount(event.event)) {\n            // There are remaining event listeners\n            return;\n        }\n        const subId = this._subIds[tag];\n        if (!subId) {\n            return;\n        }\n        delete this._subIds[tag];\n        subId.then((subId) => {\n            if (!this._subs[subId]) {\n                return;\n            }\n            delete this._subs[subId];\n            this.send(\"eth_unsubscribe\", [subId]);\n        });\n    }\n    destroy() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Wait until we have connected before trying to disconnect\n            if (this.websocket.readyState === WebSocket.CONNECTING) {\n                yield (new Promise((resolve) => {\n                    this.websocket.onopen = function () {\n                        resolve(true);\n                    };\n                    this.websocket.onerror = function () {\n                        resolve(false);\n                    };\n                }));\n            }\n            // Hangup\n            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n            this.websocket.close(1000);\n        });\n    }\n}\n//# sourceMappingURL=websocket-provider.js.map"],"sourceRoot":""}